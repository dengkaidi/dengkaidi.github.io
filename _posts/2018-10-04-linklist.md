---
title: 链表
layout: post
category:
- 编程
- 数据结构
tags:
- Java
date: 2018-10-04 11:12:00 +0800
---

* TOC
{:toc}

### 链表
- 和数组相比不但存储了值，还存储了相关联的地址信息。
- 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。
- 双向链表，每个节点不止一个后续指针还包含前续指针。双向链表比单向链表占更多的空间，但是双向链表查找上一个节点的时间复杂度为O(1)，应用更广泛。`时间换空间还是空间换时间根据场景来定。`

### 链表LRU缓存淘汰算法
- 缓存淘汰策略有：先进先出(FIFO)、最少使用(LFU)、最近最少使用(LRU)。
- 基于链表实现LRU缓存淘汰算法：
1. 如果数据已在缓存链表中，遍历找到数据节点将其删除，然后插入到链表头部。
2. 若未存在，将其插入到头部。如果缓存大小上限到了将链表尾节点删除腾出空间再插入。

### 单链表操作实例
```java
public class SignalLinkList {
    // 定义节点结构
    public static class Node {
        private int data;
        private Node next;

        public Node(int data, Node next) {
            this.data = data;
            this.next = next;
        }

        public int getData() {
            return data;
        }
    }
    // 头节点
    private Node head = null;

    public void insertToHead(int value) {
        Node node = new Node(value, null);
        insertToHead(node);
    }

    // 在头部插入
    public void insertToHead(Node node) {
        if (head == null) {
            head = node;
        } else {
            node.next = head;
            head = node;
        }
    }

    public void insertAfter(Node preNode, int data) {
        Node newNode = new Node(data, null);
        newNode.next = preNode;
        preNode.next = newNode;
    }

    public void insertBefore(Node aftNode, int data) {
        Node newNode = new Node(data, null);
        if (aftNode == head) {
            insertToHead(newNode);
            return ;
        }
        // 遍历找到插入位置
        Node q = head;
        while (q != null && q.next != aftNode) {
            q = q.next;
        }

        if (q == null) {
            return ;
        }

        newNode.next = q.next;
        q.next = newNode;
    }

    public void deleteByNode(Node node) {
        if (head == null || node == null) return ;
        if (node == head ) {
            head = head.next;
        }

        Node q = head;
        while (q != null && q.next != node) {
            q = q.next;
        }

        if (q == null) {
            return ;
        }

        q.next = q.next.next;
    }
}

```